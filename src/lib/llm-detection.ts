/**
 * LLM Detection Service
 * Detects if a PR was generated by AI tools like Copilot, Cursor, Codeium, etc.
 */

export interface DetectionSignal {
  type: 'author_type' | 'username_pattern' | 'label' | 'body_pattern' | 'commit_coauthor';
  match: string;
  confidence: number;
  tool?: string;
}

export interface LLMDetectionResult {
  isLLMGenerated: boolean;
  tool: string | null;
  confidence: number;
  signals: DetectionSignal[];
}

export interface PRData {
  author: {
    login: string;
    type?: string;
  };
  title: string;
  body?: string | null;
  labels?: Array<{ name: string }>;
  commits?: Array<{
    commit: {
      message: string;
      author?: { name?: string };
    };
  }>;
}

// Known bot usernames and patterns
// IMPORTANT: Specific tool patterns must come BEFORE generic bot patterns
const BOT_USERNAME_PATTERNS: Array<{ pattern: RegExp; tool: string; confidence: number }> = [
  // Specific bot tools (match first)
  { pattern: /^dependabot/i, tool: 'dependabot', confidence: 0.98 },
  { pattern: /^renovate/i, tool: 'renovate', confidence: 0.98 },
  { pattern: /^copilot/i, tool: 'copilot', confidence: 0.98 },
  { pattern: /^github-actions/i, tool: 'github-actions', confidence: 0.98 },
  { pattern: /^snyk-bot/i, tool: 'snyk', confidence: 0.98 },
  { pattern: /^codecov/i, tool: 'codecov', confidence: 0.98 },
  { pattern: /^greenkeeper/i, tool: 'greenkeeper', confidence: 0.98 },
  { pattern: /^semantic-release/i, tool: 'semantic-release', confidence: 0.98 },
  // AI coding tools
  { pattern: /^aider/i, tool: 'aider', confidence: 0.98 },
  { pattern: /^devin/i, tool: 'devin', confidence: 0.98 },
  { pattern: /^cody/i, tool: 'cody', confidence: 0.98 },
  { pattern: /^tabnine/i, tool: 'tabnine', confidence: 0.98 },
  { pattern: /^codewhisperer/i, tool: 'codewhisperer', confidence: 0.98 },
  { pattern: /^amazon-q/i, tool: 'amazon-q', confidence: 0.98 },
  { pattern: /^sweep/i, tool: 'sweep', confidence: 0.98 },
  { pattern: /^grit/i, tool: 'grit', confidence: 0.98 },
  { pattern: /^codegen/i, tool: 'codegen', confidence: 0.95 },
  // Generic bot patterns (match last as fallback)
  { pattern: /\[bot\]$/i, tool: 'bot', confidence: 0.9 },
  { pattern: /-bot$/i, tool: 'bot', confidence: 0.8 },
];

// Label patterns that indicate AI/bot involvement
const AI_LABEL_PATTERNS: Array<{ pattern: RegExp; tool: string | null; confidence: number }> = [
  { pattern: /^ai[-\s]?generated$/i, tool: null, confidence: 0.9 },
  { pattern: /^ai[-\s]?assisted$/i, tool: null, confidence: 0.85 },
  { pattern: /^llm$/i, tool: null, confidence: 0.9 },
  { pattern: /^copilot$/i, tool: 'copilot', confidence: 0.9 },
  { pattern: /^cursor$/i, tool: 'cursor', confidence: 0.9 },
  { pattern: /^codeium$/i, tool: 'codeium', confidence: 0.9 },
  { pattern: /^aider$/i, tool: 'aider', confidence: 0.9 },
  { pattern: /^devin$/i, tool: 'devin', confidence: 0.9 },
  { pattern: /^cody$/i, tool: 'cody', confidence: 0.9 },
  { pattern: /^tabnine$/i, tool: 'tabnine', confidence: 0.9 },
  { pattern: /^codewhisperer$/i, tool: 'codewhisperer', confidence: 0.9 },
  { pattern: /^amazon[-\s]?q$/i, tool: 'amazon-q', confidence: 0.9 },
  { pattern: /^sweep$/i, tool: 'sweep', confidence: 0.9 },
  { pattern: /^grit$/i, tool: 'grit', confidence: 0.9 },
  { pattern: /^bot$/i, tool: 'bot', confidence: 0.7 },
  { pattern: /^automated$/i, tool: null, confidence: 0.7 },
  { pattern: /^auto[-\s]?merge$/i, tool: null, confidence: 0.6 },
  { pattern: /^dependencies$/i, tool: 'dependabot', confidence: 0.5 },
];

// Body patterns that indicate AI generation
const BODY_PATTERNS: Array<{ pattern: RegExp; tool: string | null; confidence: number }> = [
  { pattern: /generated\s+(?:by|with|using)\s+(?:github\s+)?copilot/i, tool: 'copilot', confidence: 0.95 },
  { pattern: /generated\s+(?:by|with|using)\s+cursor/i, tool: 'cursor', confidence: 0.95 },
  { pattern: /generated\s+(?:by|with|using)\s+codeium/i, tool: 'codeium', confidence: 0.95 },
  { pattern: /generated\s+(?:by|with|using)\s+claude/i, tool: 'claude', confidence: 0.95 },
  { pattern: /generated\s+(?:by|with|using)\s+chatgpt/i, tool: 'chatgpt', confidence: 0.95 },
  { pattern: /generated\s+(?:by|with|using)\s+gpt-?4/i, tool: 'gpt4', confidence: 0.95 },
  // Additional AI coding tools
  { pattern: /generated\s+(?:by|with|using)\s+aider/i, tool: 'aider', confidence: 0.95 },
  { pattern: /generated\s+(?:by|with|using)\s+devin/i, tool: 'devin', confidence: 0.95 },
  { pattern: /generated\s+(?:by|with|using)\s+cody/i, tool: 'cody', confidence: 0.95 },
  { pattern: /generated\s+(?:by|with|using)\s+tabnine/i, tool: 'tabnine', confidence: 0.95 },
  { pattern: /generated\s+(?:by|with|using)\s+codewhisperer/i, tool: 'codewhisperer', confidence: 0.95 },
  { pattern: /generated\s+(?:by|with|using)\s+amazon[-\s]?q/i, tool: 'amazon-q', confidence: 0.95 },
  { pattern: /generated\s+(?:by|with|using)\s+sweep/i, tool: 'sweep', confidence: 0.95 },
  { pattern: /generated\s+(?:by|with|using)\s+grit/i, tool: 'grit', confidence: 0.95 },
  { pattern: /aider:\s/i, tool: 'aider', confidence: 0.9 },
  { pattern: /\[aider\]/i, tool: 'aider', confidence: 0.9 },
  { pattern: /\[devin\]/i, tool: 'devin', confidence: 0.9 },
  { pattern: /ai[-\s]?generated/i, tool: null, confidence: 0.85 },
  { pattern: /\[ai\]/i, tool: null, confidence: 0.8 },
  { pattern: /created\s+(?:by|with)\s+ai/i, tool: null, confidence: 0.85 },
  { pattern: /ü§ñ\s*generated/i, tool: null, confidence: 0.8 },
  { pattern: /this\s+pr\s+was\s+(?:auto[-\s]?)?generated/i, tool: null, confidence: 0.75 },
  { pattern: /automated\s+pull\s+request/i, tool: null, confidence: 0.7 },
];

// Commit co-author patterns
const COAUTHOR_PATTERNS: Array<{ pattern: RegExp; tool: string; confidence: number }> = [
  { pattern: /co-authored-by:.*copilot/i, tool: 'copilot', confidence: 0.95 },
  { pattern: /co-authored-by:.*cursor/i, tool: 'cursor', confidence: 0.95 },
  { pattern: /co-authored-by:.*codeium/i, tool: 'codeium', confidence: 0.95 },
  { pattern: /co-authored-by:.*claude/i, tool: 'claude', confidence: 0.95 },
  // Additional AI coding tools
  { pattern: /co-authored-by:.*aider/i, tool: 'aider', confidence: 0.95 },
  { pattern: /co-authored-by:.*devin/i, tool: 'devin', confidence: 0.95 },
  { pattern: /co-authored-by:.*cody/i, tool: 'cody', confidence: 0.95 },
  { pattern: /co-authored-by:.*tabnine/i, tool: 'tabnine', confidence: 0.95 },
  { pattern: /co-authored-by:.*codewhisperer/i, tool: 'codewhisperer', confidence: 0.95 },
  { pattern: /co-authored-by:.*amazon[-\s]?q/i, tool: 'amazon-q', confidence: 0.95 },
  { pattern: /co-authored-by:.*sweep/i, tool: 'sweep', confidence: 0.95 },
  { pattern: /co-authored-by:.*grit/i, tool: 'grit', confidence: 0.95 },
  { pattern: /co-authored-by:.*\[bot\]/i, tool: 'bot', confidence: 0.9 },
  { pattern: /co-authored-by:.*github-actions/i, tool: 'github-actions', confidence: 0.9 },
];

function checkAuthorType(author: PRData['author']): DetectionSignal | null {
  if (author.type?.toLowerCase() === 'bot') {
    return {
      type: 'author_type',
      match: `author.type = "${author.type}"`,
      confidence: 1.0,
      tool: 'bot',
    };
  }
  return null;
}

function checkUsernamePatterns(username: string): DetectionSignal | null {
  for (const { pattern, tool, confidence } of BOT_USERNAME_PATTERNS) {
    if (pattern.test(username)) {
      return {
        type: 'username_pattern',
        match: username,
        confidence,
        tool,
      };
    }
  }
  return null;
}

function checkLabels(labels?: Array<{ name: string }>): DetectionSignal[] {
  if (!labels?.length) return [];

  const signals: DetectionSignal[] = [];
  for (const label of labels) {
    for (const { pattern, tool, confidence } of AI_LABEL_PATTERNS) {
      if (pattern.test(label.name)) {
        signals.push({
          type: 'label',
          match: label.name,
          confidence,
          tool: tool || undefined,
        });
        break;
      }
    }
  }
  return signals;
}

function checkBodyPatterns(body?: string | null): DetectionSignal[] {
  if (!body) return [];

  const signals: DetectionSignal[] = [];
  for (const { pattern, tool, confidence } of BODY_PATTERNS) {
    const match = body.match(pattern);
    if (match) {
      signals.push({
        type: 'body_pattern',
        match: match[0],
        confidence,
        tool: tool || undefined,
      });
    }
  }
  return signals;
}

function checkCommitCoauthors(commits?: PRData['commits']): DetectionSignal[] {
  if (!commits?.length) return [];

  const signals: DetectionSignal[] = [];
  const seenTools = new Set<string>();

  for (const commit of commits) {
    const message = commit.commit.message;
    for (const { pattern, tool, confidence } of COAUTHOR_PATTERNS) {
      if (!seenTools.has(tool) && pattern.test(message)) {
        const match = message.match(pattern);
        signals.push({
          type: 'commit_coauthor',
          match: match?.[0] || 'Co-authored-by',
          confidence,
          tool,
        });
        seenTools.add(tool);
      }
    }
  }
  return signals;
}

/**
 * Detect if a PR was generated by an LLM or AI tool
 */
export function detectLLMGenerated(pr: PRData): LLMDetectionResult {
  const signals: DetectionSignal[] = [];

  // 1. Check author type (highest priority)
  const authorTypeSignal = checkAuthorType(pr.author);
  if (authorTypeSignal) signals.push(authorTypeSignal);

  // 2. Check username patterns
  const usernameSignal = checkUsernamePatterns(pr.author.login);
  if (usernameSignal) signals.push(usernameSignal);

  // 3. Check labels
  const labelSignals = checkLabels(pr.labels);
  signals.push(...labelSignals);

  // 4. Check body patterns
  const bodySignals = checkBodyPatterns(pr.body);
  signals.push(...bodySignals);

  // 5. Check commit co-authors
  const commitSignals = checkCommitCoauthors(pr.commits);
  signals.push(...commitSignals);

  // Calculate overall result
  if (signals.length === 0) {
    return {
      isLLMGenerated: false,
      tool: null,
      confidence: 0,
      signals: [],
    };
  }

  // Find highest confidence signal
  const maxConfidence = Math.max(...signals.map(s => s.confidence));

  // Determine tool (prefer specific tools over generic 'bot')
  const toolSignals = signals.filter(s => s.tool && s.tool !== 'bot');
  const sortedToolSignals = toolSignals.sort((a, b) => b.confidence - a.confidence);
  const topToolSignal = sortedToolSignals[0];
  let primaryTool: string | null = null;
  if (topToolSignal?.tool) {
    primaryTool = topToolSignal.tool;
  } else {
    const fallbackSignal = signals.find(s => s.tool);
    primaryTool = fallbackSignal?.tool ?? null;
  }

  return {
    isLLMGenerated: maxConfidence >= 0.5,
    tool: primaryTool,
    confidence: maxConfidence,
    signals,
  };
}

/**
 * Get a display label for the detected tool
 */
export function getToolDisplayLabel(tool: string | null): string {
  if (!tool) return 'AI';

  const labels: Record<string, string> = {
    copilot: 'Copilot',
    cursor: 'Cursor',
    codeium: 'Codeium',
    claude: 'Claude',
    chatgpt: 'ChatGPT',
    gpt4: 'GPT-4',
    dependabot: 'Dependabot',
    renovate: 'Renovate',
    snyk: 'Snyk',
    codecov: 'Codecov',
    greenkeeper: 'Greenkeeper',
    'semantic-release': 'Semantic Release',
    'github-actions': 'GitHub Actions',
    // Additional AI coding tools
    aider: 'Aider',
    devin: 'Devin',
    cody: 'Cody',
    tabnine: 'Tabnine',
    codewhisperer: 'CodeWhisperer',
    'amazon-q': 'Amazon Q',
    sweep: 'Sweep',
    grit: 'Grit',
    codegen: 'Codegen',
    bot: 'Bot',
  };

  return labels[tool] || tool.charAt(0).toUpperCase() + tool.slice(1);
}

/**
 * Get emoji for the detected tool
 */
export function getToolEmoji(tool: string | null): string {
  if (!tool) return 'ü§ñ';

  const emojis: Record<string, string> = {
    copilot: 'ü§ñ',
    cursor: 'üñ±Ô∏è',
    codeium: '‚ö°',
    claude: 'üß†',
    chatgpt: 'üí¨',
    gpt4: 'üí¨',
    dependabot: 'üîÑ',
    renovate: 'üîß',
    snyk: 'üîí',
    // Additional AI coding tools
    aider: 'üõ†Ô∏è',
    devin: 'üë®‚Äçüíª',
    cody: 'üêï',
    tabnine: 'üìù',
    codewhisperer: 'üîÆ',
    'amazon-q': 'üì¶',
    sweep: 'üßπ',
    grit: 'üéØ',
    codegen: '‚öôÔ∏è',
    'github-actions': '‚ö°',
    codecov: 'üìä',
    greenkeeper: 'üå±',
    'semantic-release': 'üöÄ',
    bot: 'ü§ñ',
  };

  return emojis[tool] || 'ü§ñ';
}
